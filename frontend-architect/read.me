front end architect 


* continuous integration, continous delivery, continuous release
* SOLID - single,
    * 	 open closed,
    * 	 liskovak substitute principle, 
    * 	Interface principle on clients, 
    * 	Dependency Inversion Principle. Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions.
* Twelve-Factor App principles
    * Codebase - There should be exactly one codebase for a deployed service with the codebase being used for many deployments.
    * Dependencies - All dependencies should be declared, with no implicit reliance on system tools or libraries.
    * Config - Configuration that varies between deployments should be stored in the environment.
    * Backing services All backing services are treated as attached resources and attached and detached by the execution environment.
    * Build, release, run - The delivery pipeline should strictly consist of build, release, run.
    * Processes - Applications should be deployed as one or more stateless processes with persisted data stored on a backing service.
    * Port binding - Self-contained services should make themselves available to other services by specified ports.
    * Concurrency - Concurrency is advocated by scaling individual processes.
    * Disposability - Fast startup and shutdown are advocated for a more robust and resilient system.
    * Dev/Prod parity - All environments should be as similar as possible.
    * Logs - Applications should produce logs as event streams and leave the execution environment to aggregate.
    * Admin Processes - Any needed admin tasks should be kept in source control and packaged with the application.
* 
* lazy load 

* System Design 

    * ask questions - goal, scope etc 
        * pwa needed? platforms - mobile, deskto petc, 
        * mobile first needed or no 
        * SEO a concern? ssr needed ? spa enough etc 
        * vol of service & team members
        * mvp and core features
        * shinning point for srvice & dx
        * future radmap
        * how many interactions occur in a day 
        * avg api response - depends on infra 
        * 
    * data flow, user flow
        * performance  - smoothness and speed - both can be handled in combination
        * page sack/gloabal state/api caching 
        * skeletons - react skeleton
        * you can use global state to helps data
        * caching using effects
        * new ui using the instant interactions 
        * native like ui components -  animations, transitions , gestures
    * Speed / Peformance
        * preload/prefetch
        * Code splitting (skeleton) - fb article read  - react - lazy, suspense and fallbackx`
        * cahing/cdn - content hash, static resources, cache resources, some apis,
        * service worker/offline
        * lazy-load
        * Auto pager
        * Infinite scrol
        * SSR/initial data feed
        * Within viewport update(api. ETC) 
        * Images 
            * compress
            * lazy load placeholdr
            * progessive imags
            * use svg for icons, old days use to use sprite imaging
            * caching /http2 - cache digest - cookie polyfill
        * APIs
            * Poll/ web socket /sse
            * api aggregating - bpf
            * Graphql 
            * cahing / http2
        * RAIL model
            * response (100ms)
            * Animation (fram with in 10ms)
            * idle (use idle tiem, 50ms)
            * Load
        * Matrix
            * dom content loaded 
            * LOAD
            * First  contentful paint
            * first meaning paint
            * speed index
            * fist cpu idle
            * time to interactive
            * fist input dealy
            * total blocking time
            * largst contentful paint
        * FB core values
            * move fast 
            * be bold
            * focus on impact 
            * be open
            * build social value
        * 
    * mvp - core components, apis and many elements etc 
    * state of the UI components
    * seperate the parts - ui and logic 
    * core spec 
    * 	components 
        * 	typeahead



================================

Understand what it is
* Who is the customer?
* What problems we solved for them?
* What are expected to create?
 
Decide the scope that suits
- To Dos and not To Dos
- Check with the interviewer

System Design
* What’s the goal?
    * Basic Functional goal
    * Non-functional goal
* What is the MVP?
* What is the Data flow/API?
* What is the states of the UI?
* How would you separate them from parts and put together
    * Components composition
    * Components communication 
* What is the core spec?

Product design
* The goal of the web service
* Relation to the native app? 
    * Replica? 
    * Lite version? 
    * PWA?
* Target platform
    * Mobile
    * Desktop
* Mobile first?
* SEO/SSR/SPA?
* Volumn of the service
* Team members
* MVP, core features?
* Highlights?
* Future roadmap?

Assumptions on background
* DAU/MAU of the service
* How many Interactions?
* Average API response?

Big Picture
* Draw diagram or list outline
* Flow
    * Data Flow
    * User interaction flow
* Check with Interviewer

Key challenges, bottleneck (smoothness & speed)
* Smoothness
    * Instant Go Back
        * Page stack
        * Global state
        * API Caching + WebSocket update
    * Instant Go Forward
        * Skeleton
        * Loading indicator
    * Instant Interaction Response
        * Passive event listener (scrolling,  {passive: true} in “touchstart” | “touchmove”)
    * Native like animation/transition
    * Hand Gesture
    * Native like UI-Components
* Speed
    * First screen
        * SSR + initial Data
    * Multiple bundling 
        * For mainstream/traditional browsers
    * Loading
        * Code splitting
        * Lazy load
            * Offscreen
                * Lazy load Image/videos
                * Lazy UI component update
            * Infinite Scroll
        * Preloading
            * Background module loading
            * Data prefetching
            * HTTP/2 Push
                * <link rel="preload" href="/styles.css" as="style">
                * <link rel="preload" href="/example.png" as="image">
            * Service Worker Cache API
            * Inline CSS/Image Base64
    * Caching
        * CDN
        * HTTP Header
        * Service Worker Cache API / Offline
    * Resources
        * Images 
            * Compression
            * Base64
            * Lazy Load
            * Progressive Resolution Images
            * SVGs for icons
            * Caching
* API
    * Long polling
        * Mobile battery consumption 
    * WebSocket
        * don’t support HTTP proxies, but only TCP proxies; HTTP DoS service doesn’t work
        * stateful, a connection doesn’t scale to new server
        * Mobile battery consumption, even more over antenna 
    * SSE
        * A HTTP connection to transfer streams many times
        * One way: from server to clients
        * Multiplex over HTTP/2
        * new EventSource('URL’).addEventListener(“message”, handler)
            * 'Content-Type': 'text/event-stream'
    * BFF
        * Backend For Frontend
        * API aggregation/Composition/Computation
        * Over micro-services 
        * GraphQL
    * Caching
    * RAIL speed framework
        * https://web.dev/rail/
        * Response: process events in under 50ms
            * So that the total response could be 100ms
        * Animation: produce a frame in 10 ms
        * Idle: maximize idle time
            * Fast initial load, then work in Idle time 
            * <50s processing to allow user for further interaction any time
            * Stop on user interaction 
        * Load: deliver content and become interactive in under 5 seconds
* Matrix
    * DOMContentLoad
    * Load
    * Total Blocking time
        * FCP: First Content Paint
        * TTI: Time to Interactive
        * First Input Delay
    * Latest content paint < 2.5s

Trade-off, alternatives, TODO
* Nothing is perfect
* Try to list up possible improvements
* And anything want to do if more time given
	
